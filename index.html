<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ”¹ NFC Mifare Editor (Locale) ğŸ”¹</title>
  <style>
    /* =============== STILI GENERALI =============== */
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #e0f7fa, #b2ebf2);
      margin: 0;
      padding: 50px;
      color: #333;
      transition: all 0.4s ease;
    }
    /* Tema scuro */
    body.dark {
      background: linear-gradient(135deg, #1e272e, #2c3e50);
      color: #e0e0e0;
    }

    .container {
      max-width: 700px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
      transition: all 0.4s ease;
      box-sizing: border-box;
    }
    /* Tema scuro per il contenitore */
    .container.dark {
      background: rgba(40, 50, 60, 0.95);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
    }

    h1 {
      text-align: center;
      color: #0288d1;
      margin-bottom: 30px;
      font-size: 32px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .dark h1 {
      color: #4fc3f7;
    }

    .top-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 20px;
      margin-bottom: 20px;
      align-items: center;
    }

    /* =============== SWITCH TEMA =============== */
    .switch {
      display: inline-block;
      position: relative;
    }
    .switch__input {
      clip: rect(1px, 1px, 1px, 1px);
      clip-path: inset(50%);
      height: 1px;
      width: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
    }
    .switch__label {
      position: relative;
      display: inline-block;
      width: 120px;
      height: 60px;
      background-color: #2B2B2B;
      border: 5px solid #5B5B5B;
      border-radius: 9999px;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(.46,.03,.52,.96);
    }
    .switch__indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) translateX(-72%);
      display: block;
      width: 40px;
      height: 40px;
      background-color: #7B7B7B;
      border-radius: 9999px;
      box-shadow: 10px 0px 0 0 rgba(0, 0, 0, 0.2) inset;
      transition: all 0.4s cubic-bezier(.46,.03,.52,.96);
    }
    .switch__indicator::before,
    .switch__indicator::after {
      position: absolute;
      content: '';
      display: block;
      background-color: #FFFFFF;
      border-radius: 9999px;
    }
    .switch__indicator::before {
      top: 7px;
      left: 7px;
      width: 9px;
      height: 9px;
      opacity: 0.6;
    }
    .switch__indicator::after {
      bottom: 8px;
      right: 6px;
      width: 14px;
      height: 14px;
      opacity: 0.8;
    }
    .switch__decoration {
      position: absolute;
      top: 65%;
      left: 50%;
      display: block;
      width: 5px;
      height: 5px;
      background-color: #FFFFFF;
      border-radius: 9999px;
      animation: twinkle 0.8s infinite -0.6s;
    }
    .switch__decoration::before,
    .switch__decoration::after {
      position: absolute;
      display: block;
      content: '';
      width: 5px;
      height: 5px;
      background-color: #FFFFFF;
      border-radius: 9999px;
    }
    .switch__decoration::before {
      top: -20px;
      left: 10px;
      opacity: 1;
      animation: twinkle 0.6s infinite;
    }
    .switch__decoration::after {
      top: -7px;
      left: 30px;
      animation: twinkle 0.6s infinite -0.2s;
    }
    @keyframes twinkle {
      50% { opacity: 0.2; }
    }
    .switch__input:checked + .switch__label {
      background-color: #8FB5F5;
      border-color: #347CF8;
    }
    .switch__input:checked + .switch__label .switch__indicator {
      background-color: #ECD21F;
      box-shadow: none;
      transform: translate(-50%, -50%) translateX(72%);
    }
    .switch__input:checked + .switch__label .switch__indicator::before,
    .switch__input:checked + .switch__label .switch__indicator::after {
      display: none;
    }
    .switch__input:checked + .switch__label .switch__decoration {
      top: 50%;
      transform: translate(0%, -50%);
      animation: cloud 8s linear infinite;
      width: 20px;
      height: 20px;
    }
    .switch__input:checked + .switch__label .switch__decoration::before {
      width: 10px;
      height: 10px;
      top: auto;
      bottom: 0;
      left: -8px;
      animation: none;
    }
    .switch__input:checked + .switch__label .switch__decoration::after {
      width: 15px;
      height: 15px;
      top: auto;
      bottom: 0;
      left: 16px;
      animation: none;
    }
    .switch__input:checked + .switch__label .switch__decoration,
    .switch__input:checked + .switch__label .switch__decoration::before,
    .switch__input:checked + .switch__label .switch__decoration::after {
      border-radius: 9999px 9999px 0 0;
    }
    .switch__input:checked + .switch__label .switch__decoration::after {
      border-bottom-right-radius: 9999px;
    }
    @keyframes cloud {
      0% { transform: translate(0%, -50%); }
      50% { transform: translate(-50%, -50%); }
      100% { transform: translate(0%, -50%); }
    }

    /* =============== SEZIONI E BLOCCHI =============== */
    .section {
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(245, 245, 245, 0.8);
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
      transition: all 0.4s ease;
      box-sizing: border-box;
    }
    .dark .section {
      background: rgba(60, 70, 80, 0.8);
    }
    .section h3 {
      margin: 0 0 15px;
      color: #0277bd;
      font-size: 22px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    .dark .section h3 {
      color: #81d4fa;
    }

    .file-input {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
    }
    .file-input input[type="file"] {
      display: none;
    }
    .file-input label {
      padding: 12px 25px;
      background: linear-gradient(135deg, #4caf50, #45a049);
      color: white;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    .file-input label:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .info p {
      margin: 10px 0;
      font-size: 16px;
      line-height: 1.5;
    }
    .info span {
      font-weight: bold;
      color: #d81b60;
    }
    .dark .info span {
      color: #f06292;
    }

    .form-group {
      margin: 15px 0;
    }
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
    }
    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px;
      margin-bottom: 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-sizing: border-box;
      background: #fff;
      transition: all 0.3s ease;
    }
    .dark input[type="text"], .dark input[type="number"], .dark select {
      background: #546e7a;
      border-color: #78909c;
      color: #fff;
    }

    .buttons-section {
      display: flex;
      gap: 20px;
    }
    button {
      flex: 1;
      padding: 12px 25px;
      background: linear-gradient(135deg, #0288d1, #0277bd);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    /* =============== TEXTAREA =============== */
    textarea {
      display: block;
      width: 100%;
      max-width: 100%;
      height: 200px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      background: #fafafa;
      transition: all 0.4s ease;
      box-sizing: border-box;
      resize: none;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .dark textarea {
      background: #546e7a;
      border-color: #78909c;
      color: #fff;
    }
    textarea::placeholder {
      color: #000;
    }
    .dark textarea::placeholder {
      color: #fff;
    }
  </style>
</head>
<body class="dark">
  <div class="top-buttons">
    <div class="switch">
      <input type="checkbox" class="switch__input" id="themeSwitch">
      <label class="switch__label" for="themeSwitch">
        <span class="switch__indicator"></span>
        <span class="switch__decoration"></span>
      </label>
    </div>
    <span id="langToggle" style="font-size: 24px; cursor: pointer;">ğŸ‡®ğŸ‡¹</span>
  </div>

  <div class="container dark" id="mainContainer">
    <h1 id="mainTitle">ğŸ”¹ NFC Mifare Editor (Locale) ğŸ”¹</h1>
    
    <div class="section">
      <div class="file-input">
        <label for="fileInput" id="fileInputLabel">ğŸ“‚ Carica File:</label>
        <input type="file" id="fileInput" accept=".nfc,.mct">
      </div>
    </div>

    <div class="section">
      <h3 id="extractedDataTitle">ğŸ“‹ Dati Estratti</h3>
      <div class="info">
        <p>â„¹ï¸ Uploaded File: <span id="fileNameLabel"></span> <span id="fileName">N/A</span></p>
        <p>ğŸ†” UID: <span id="uid">N/A</span></p>
        <p>ğŸ’³ Current Credit: <span id="credit">N/A</span></p>
        <p>ğŸ“… Last Recharge Date: <span id="date">N/A</span></p>
        <p>ğŸ”’ Encoding Type: <span id="encoding">N/A</span></p>
        <p>ğŸ’µ Last Operation Credit: <span id="lastOpCredit">N/A</span></p>
        <p>ğŸ•’ Last Operation Date: <span id="lastOpDate">N/A</span></p>
      </div>
    </div>

    <div class="section">
      <h3 id="editDataTitle">âœï¸ Modifica Dati</h3>
      <!-- Campi di esempio per eventuali modifiche (non influiscono sulla conversione base) -->
      <div class="form-group">
        <label><input type="checkbox" id="keepUid" checked> <span id="keepUidText">ğŸ”„ Mantieni UID Corrente</span></label>
        <label id="newUidLabel">ğŸ†” Nuovo UID:</label>
        <select id="uid0" disabled></select>
        <select id="uid1" disabled></select>
        <select id="uid2" disabled></select>
        <select id="uid3" disabled></select>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="keepCredit" checked> <span id="keepCreditText">ğŸ”„ Mantieni Credito Corrente</span></label>
        <label id="newCreditLabel">ğŸ’³ Nuovo Credito (â‚¬):</label>
        <input type="number" id="newCredit" step="0.01" min="0" disabled>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="keepDate" checked> <span id="keepDateText">ğŸ”„ Mantieni Data Corrente</span></label>
        <label id="newDateLabel">ğŸ“… Nuova Data di Ricarica:</label>
        <select id="day" disabled></select>
        <select id="month" disabled></select>
        <select id="year" disabled></select>
        <select id="hours" disabled></select>
        <select id="minutes" disabled></select>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="keepLastOpCredit" checked> <span id="keepLastOpCreditText">ğŸ”„ Mantieni Ultimo Credito Operazione</span></label>
        <label id="newLastOpCreditLabel">ğŸ’µ Nuovo Ultimo Credito Operazione (â‚¬):</label>
        <input type="number" id="newLastOpCredit" step="0.01" min="0" disabled>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="keepLastOpDate" checked> <span id="keepLastOpDateText">ğŸ”„ Mantieni Data Ultima Operazione</span></label>
        <label id="newLastOpDateLabel">ğŸ•’ Nuova Data Ultima Operazione:</label>
        <select id="lastOpDay" disabled></select>
        <select id="lastOpMonth" disabled></select>
        <select id="lastOpYear" disabled></select>
        <select id="lastOpHours" disabled></select>
        <select id="lastOpMinutes" disabled></select>
      </div>
    </div>

    <div class="section buttons-section">
      <button id="createNewFileBtn" type="button">ğŸ“ Crea Nuovo File</button>
      <button id="convertBtn" type="button">ğŸ”„ Converti</button>
    </div>

    <div class="section">
      <textarea id="fileContent" readonly placeholder="File Content"></textarea>
    </div>

    <div class="section" style="text-align: center;">
      <button 
        id="donateBtn" 
        type="button" 
        style="padding: 15px 30px; font-size: 18px;"
        onclick="window.open('https://github.com/Lotverp/Lotverp/blob/main/donate.md');">
        â˜• Donate â˜•
      </button>
    </div>

  </div>

  <script>
    // Variabili globali
    let fileContent = "";
    let fileExtension = "";
    let fileName = "";
    let allBlocks = {};
    let block0Hex = [];
    let keysHex = [];
    let lastOpCreditHex = [];
    let lastOpDateHex = [];
    let sectorKeys = {};
    let currentLanguage = "it"; // Lingua iniziale

    // Testi in entrambe le lingue
    const texts = {
      it: {
        fileInputLabel: "ğŸ“‚ Carica File",
        mainTitle: "ğŸ”¹ Editor NFC Mifare ğŸ”¹",
        extractedDataTitle: "ğŸ“‹ Dati Estratti",
        editDataTitle: "âœï¸ Modifica Dati",
        keepUidText: "ğŸ”„ Mantieni UID Corrente",
        newUidLabel: "ğŸ†” Nuovo UID:",
        keepCreditText: "ğŸ”„ Mantieni Credito Corrente",
        newCreditLabel: "ğŸ’³ Nuovo Credito (â‚¬):",
        keepDateText: "ğŸ”„ Mantieni Data Corrente",
        newDateLabel: "ğŸ“… Nuova Data di Ricarica:",
        keepLastOpCreditText: "ğŸ”„ Mantieni Ultimo Credito Operazione",
        newLastOpCreditLabel: "ğŸ’µ Nuovo Ultimo Credito Operazione (â‚¬):",
        keepLastOpDateText: "ğŸ”„ Mantieni Data Ultima Operazione",
        newLastOpDateLabel: "ğŸ•’ Nuova Data Ultima Operazione:",
        errorLoad: "âŒ Carica prima un file!",
        errorBlock: "âŒ Blocco 0, 4, 5 o 6 non trovato!",
        successMsg: "Dati aggiornati con successo!",
        convertSuccessMsg: "File convertito con successo!",
        months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
      },
      en: {
        fileInputLabel: "ğŸ“‚ Load File",
        fileNameLabel: "ğŸ“‚ File Name:",
        mainTitle: "ğŸ”¹ NFC Mifare Editor ğŸ”¹",
        extractedDataTitle: "ğŸ“‹ Extracted Data",
        editDataTitle: "âœï¸ Edit Data",
        keepUidText: "ğŸ”„ Keep Current UID",
        newUidLabel: "ğŸ†” New UID:",
        keepCreditText: "ğŸ”„ Keep Current Credit",
        newCreditLabel: "ğŸ’³ New Credit (â‚¬):",
        keepDateText: "ğŸ”„ Keep Current Date",
        newDateLabel: "ğŸ“… New Recharge Date:",
        keepLastOpCreditText: "ğŸ”„ Keep Last Operation Credit",
        newLastOpCreditLabel: "ğŸ’µ New Last Operation Credit (â‚¬):",
        keepLastOpDateText: "ğŸ”„ Keep Last Operation Date",
        newLastOpDateLabel: "ğŸ•’ New Last Operation Date:",
        errorLoad: "âŒ Load a file first!",
        errorBlock: "âŒ Block 0, 4, 5, or 6 not found!",
        successMsg: "Data updated successfully!",
        convertSuccessMsg: "File converted successfully!",
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
      }
    };

    // Funzione per aggiornare l'interfaccia in base alla lingua corrente
    function updateLanguage() {
      document.getElementById("fileInputLabel").textContent = texts[currentLanguage].fileInputLabel + ":";
      document.getElementById("fileNameLabel").textContent = texts[currentLanguage].fileNameLabel;
      document.getElementById("mainTitle").textContent = texts[currentLanguage].mainTitle;
      document.getElementById("extractedDataTitle").textContent = texts[currentLanguage].extractedDataTitle;
      document.getElementById("editDataTitle").textContent = texts[currentLanguage].editDataTitle;
      document.getElementById("keepUidText").textContent = texts[currentLanguage].keepUidText;
      document.getElementById("newUidLabel").textContent = texts[currentLanguage].newUidLabel;
      document.getElementById("keepCreditText").textContent = texts[currentLanguage].keepCreditText;
      document.getElementById("newCreditLabel").textContent = texts[currentLanguage].newCreditLabel;
      document.getElementById("keepDateText").textContent = texts[currentLanguage].keepDateText;
      document.getElementById("newDateLabel").textContent = texts[currentLanguage].newDateLabel;
      document.getElementById("keepLastOpCreditText").textContent = texts[currentLanguage].keepLastOpCreditText;
      document.getElementById("newLastOpCreditLabel").textContent = texts[currentLanguage].newLastOpCreditLabel;
      document.getElementById("keepLastOpDateText").textContent = texts[currentLanguage].keepLastOpDateText;
      document.getElementById("newLastOpDateLabel").textContent = texts[currentLanguage].newLastOpDateLabel;
    }

    // Gestione del cambio lingua tramite il click sulla bandiera
    document.getElementById("langToggle").addEventListener("click", function() {
      currentLanguage = currentLanguage === "it" ? "en" : "it";
      this.textContent = currentLanguage === "it" ? "ğŸ‡®ğŸ‡¹" : "ğŸ‡¬ğŸ‡§";
      updateLanguage();
    });

    // Inizializza la lingua al caricamento della pagina
    updateLanguage();

    // Popola i select con i valori esadecimali e di data/ora
    for (let i = 0; i < 256; i++) {
      const opt = document.createElement("option");
      opt.value = i;
      opt.text = i.toString(16).padStart(2, "0").toUpperCase();
      ["uid0", "uid1", "uid2", "uid3"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
    }
    for (let i = 1; i <= 31; i++) {
      const opt = document.createElement("option");
      opt.value = i;
      opt.text = i;
      ["day", "lastOpDay"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
    }
    texts.it.months.forEach((m, i) => {
      const opt = document.createElement("option");
      opt.value = i + 1;
      opt.text = m;
      ["month", "lastOpMonth"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
    });
    for (let i = 2010; i <= 2040; i++) {
      const opt = document.createElement("option");
      opt.value = i;
      opt.text = i;
      ["year", "lastOpYear"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
    }
    for (let i = 0; i < 24; i++) {
      const opt = document.createElement("option");
      opt.value = i;
      opt.text = i.toString().padStart(2, "0");
      ["hours", "lastOpHours"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
    }
    for (let i = 0; i < 60; i++) {
      const opt = document.createElement("option");
      opt.value = i;
      opt.text = i.toString().padStart(2, "0");
      ["minutes", "lastOpMinutes"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
    }

    // Gestione checkbox per abilitare/disabilitare i campi di input
    ["keepUid", "keepCredit", "keepDate", "keepLastOpCredit", "keepLastOpDate"].forEach(id => {
      document.getElementById(id).addEventListener("change", e => {
        let targetIds = [];
        if (id === "keepUid") targetIds = ["uid0", "uid1", "uid2", "uid3"];
        else if (id === "keepCredit") targetIds = ["newCredit"];
        else if (id === "keepDate") targetIds = ["day", "month", "year", "hours", "minutes"];
        else if (id === "keepLastOpCredit") targetIds = ["newLastOpCredit"];
        else if (id === "keepLastOpDate") targetIds = ["lastOpDay", "lastOpMonth", "lastOpYear", "lastOpHours", "lastOpMinutes"];
        targetIds.forEach(tid => {
          document.getElementById(tid).disabled = e.target.checked;
        });
      });
    });

    // Toggle tema scuro/chiaro
    const themeSwitch = document.getElementById("themeSwitch");
    themeSwitch.addEventListener("change", (e) => {
      document.body.classList.toggle("dark", e.target.checked);
      document.querySelector(".container").classList.toggle("dark", e.target.checked);
    });

    window.addEventListener("DOMContentLoaded", () => {
      themeSwitch.checked = true;
      document.body.classList.add("dark");
      document.getElementById("mainContainer").classList.add("dark");
    });

    // Gestione caricamento file
    document.getElementById("fileInput").addEventListener("change", function() {
      const file = this.files[0];
      if (!file) return;
      fileExtension = file.name.slice(file.name.lastIndexOf(".")).toLowerCase();
      fileName = file.name;
      document.getElementById("fileName").textContent = fileName;
      const reader = new FileReader();
      reader.onload = function(e) {
        fileContent = e.target.result;
        document.getElementById("fileContent").value = fileContent;
        parseFile(fileExtension, fileContent);
      };
      reader.readAsText(file);
    });

    // Parsing del file (solo per mostrare i dati in UI, non influisce sulla conversione)
    function parseFile(ext, content) {
      allBlocks = {};
      sectorKeys = {};
      block0Hex = [];
      keysHex = [];
      lastOpCreditHex = [];
      lastOpDateHex = [];
      const lines = content.split(/\r?\n/);
      let block0Found = false, block4Found = false, block5Found = false, block6Found = false;

      if (ext === ".mct") {
        let currentSector = -1, blockCount = 0;
        lines.forEach(line => {
          if (line.startsWith("+Sector:")) {
            currentSector = parseInt(line.split(":")[1].trim());
            blockCount = 0;
          } else if (currentSector >= 0 && line.trim() !== "") {
            const data = [];
            for (let i = 0; i < line.length; i += 2) {
              data.push(line.substr(i, 2));
            }
            const blockNum = currentSector * 4 + blockCount;
            allBlocks[blockNum] = data;
            if (blockNum === 0) {
              block0Hex = data.slice(0, 16);
              block0Found = true;
            } else if (blockNum === 4) {
              keysHex = data.slice(0, 16);
              block4Found = true;
            } else if (blockNum === 5) {
              lastOpCreditHex = data.slice(0, 16);
              block5Found = true;
            } else if (blockNum === 6) {
              lastOpDateHex = data.slice(0, 16);
              block6Found = true;
            } else if (blockCount === 3) {
              // chiavi di settore, non usate in questa demo
              sectorKeys[currentSector] = [
                data.slice(0, 6).join("").toUpperCase(),
                data.slice(10, 16).join("").toUpperCase()
              ];
            }
            blockCount++;
          }
        });
      } else {
        // Assume .nfc (Flipper format)
        lines.forEach(line => {
          if (line.startsWith("Block ")) {
            const parts = line.split(/\s+/);
            const blockNum = parseInt(parts[1].replace(":", ""));
            const data = parts.slice(2);
            allBlocks[blockNum] = data;
            if (blockNum === 0) {
              block0Hex = data.slice(0, 16);
              block0Found = true;
            } else if (blockNum === 4) {
              keysHex = data.slice(0, 16);
              block4Found = true;
            } else if (blockNum === 5) {
              lastOpCreditHex = data.slice(0, 16);
              block5Found = true;
            } else if (blockNum === 6) {
              lastOpDateHex = data.slice(0, 16);
              block6Found = true;
            }
            if (blockNum % 4 === 3 && parts.length >= 18) {
              const keyA = parts.slice(2, 8).join("").toUpperCase();
              const keyB = parts.slice(12, 18).join("").toUpperCase();
              sectorKeys[Math.floor(blockNum / 4)] = [keyA, keyB];
            }
          }
        });
      }

      if (!(block0Found && block4Found && block5Found && block6Found)) {
        alert(texts[currentLanguage].errorBlock);
        return;
      }
      updateUI();
    }

    // Funzioni di calcolo per la UI
    function calculateCredit() {
      if (keysHex.length < 7) return 0;
      const byte6 = parseInt(keysHex[5], 16);
      const byte7 = parseInt(keysHex[6], 16);
      return ((byte7 << 8) | byte6) / 100;
    }
    function calculateDate() {
      if (keysHex.length < 11) return "N/A";
      const byte7 = parseInt(keysHex[7], 16);
      const byte8 = parseInt(keysHex[8], 16);
      const byte9 = parseInt(keysHex[9], 16);
      const byte10 = parseInt(keysHex[10], 16);
      const b = (byte10 << 24) | (byte9 << 16) | (byte8 << 8) | byte7;
      if (b === 0) return "N/A";
      const minutes = (b >> 21) & 0x3F;
      const hours = (b >> 16) & 0x1F;
      const year = 2010 + ((b >> 9) & 0x1F);
      const month = (b >> 5) & 0x0F;
      const day = b & 0x1F;
      return `${day} ${texts[currentLanguage].months[month - 1] || "invalid"} ${year} ${("0" + hours).slice(-2)}:${("0" + minutes).slice(-2)}`;
    }
    function calculateLastOpCredit() {
      if (lastOpCreditHex.length < 7) return 0;
      const byte6 = parseInt(lastOpCreditHex[5], 16);
      const byte7 = parseInt(lastOpCreditHex[6], 16);
      return ((byte7 << 8) | byte6) / 100;
    }
    function calculateLastOpDate() {
      if (lastOpDateHex.length < 11) return "N/A";
      const byte7 = parseInt(lastOpDateHex[7], 16);
      const byte8 = parseInt(lastOpDateHex[8], 16);
      const byte9 = parseInt(lastOpDateHex[9], 16);
      const byte10 = parseInt(lastOpDateHex[10], 16);
      const b = (byte10 << 24) | (byte9 << 16) | (byte8 << 8) | byte7;
      if (b === 0) return "N/A";
      const minutes = (b >> 21) & 0x3F;
      const hours = (b >> 16) & 0x1F;
      const year = 2010 + ((b >> 9) & 0x1F);
      const month = (b >> 5) & 0x0F;
      const day = b & 0x1F;
      return `${day} ${texts[currentLanguage].months[month - 1] || "invalid"} ${year} ${("0" + hours).slice(-2)}:${("0" + minutes).slice(-2)}`;
    }
    function detectEncodingType() {
      if (Object.keys(sectorKeys).length === 0) return "unknown";
      let isMicroel = true;
      for (let s of [0, 1]) {
        if (!sectorKeys[s] || sectorKeys[s][0] === "FFFFFFFFFFFF" || sectorKeys[s][1] === "FFFFFFFFFFFF") {
          isMicroel = false;
        }
      }
      for (let s = 2; s < 16; s++) {
        if (!sectorKeys[s] || sectorKeys[s][0] !== "FFFFFFFFFFFF" || sectorKeys[s][1] !== "FFFFFFFFFFFF") {
          isMicroel = false;
        }
      }
      return isMicroel ? "microel" : "unknown";
    }

    // Aggiorna l'interfaccia
    function updateUI() {
      document.getElementById("uid").textContent = block0Hex.slice(0, 4).join(" ") || "00 00 00 00";
      document.getElementById("credit").textContent = calculateCredit().toFixed(2) + " â‚¬";
      document.getElementById("date").textContent = calculateDate();
      document.getElementById("encoding").textContent = detectEncodingType();
      document.getElementById("lastOpCredit").textContent = calculateLastOpCredit().toFixed(2) + " â‚¬";
      document.getElementById("lastOpDate").textContent = calculateLastOpDate();
    }

    // Crea un nuovo file con i dati eventualmente modificati
    document.getElementById("createNewFileBtn").addEventListener("click", function() {
      if (!fileContent) {
        alert(texts[currentLanguage].errorLoad);
        return;
      }
      const newContent = generateFileContent();
      const blob = new Blob([newContent], { type: "text/plain" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `new_file${fileExtension}`;
      link.click();
      alert(texts[currentLanguage].successMsg);
    });

    // CONVERSIONE IN LOCALE (JS) ================================================

    // 1) Converte da .nfc (Flipper) a .mct
    function convertFlipperToMCT(flipperContent) {
      const lines = flipperContent.split(/\r?\n/);
      const blocks = [];
      for (let line of lines) {
        if (line.startsWith("Block ")) {
          // Esempio: "Block 0: 00 11 22 33 ..."
          const match = line.match(/^Block\s+(\d+):\s+(.*)$/);
          if (!match) continue;
          const blockNum = parseInt(match[1], 10);
          const hexBytes = match[2].split(/\s+/);
          blocks[blockNum] = hexBytes;
        }
      }
      // Ricostruiamo in formato MCT
      let result = "";
      for (let sector = 0; sector < 16; sector++) {
        result += `+Sector: ${sector}\n`;
        for (let b = 0; b < 4; b++) {
          const blockNum = sector * 4 + b;
          const data = blocks[blockNum] || Array(16).fill("00");
          // In MCT ogni blocco Ã¨ una riga di 32 hex consecutivi
          const line = data.join("");
          result += line + "\n";
        }
      }
      return result;
    }

    // 2) Converte da .mct a .nfc (Flipper)
    function convertMCTToFlipper(mctContent) {
      const lines = mctContent.split(/\r?\n/);
      const blocks = [];
      let sector = -1;
      let blockCount = 0;

      // Leggiamo i blocchi
      for (let line of lines) {
        if (line.startsWith("+Sector:")) {
          sector = parseInt(line.split(":")[1].trim());
          blockCount = 0;
        } else if (sector >= 0 && line.trim() !== "") {
          // line = 32 hex char => 16 bytes
          const dataLine = line.trim();
          const hexBytes = [];
          for (let j = 0; j < dataLine.length; j += 2) {
            hexBytes.push(dataLine.substr(j, 2));
          }
          const blockNum = sector * 4 + blockCount;
          blocks[blockNum] = hexBytes;
          blockCount++;
          if (blockCount === 4) sector = -1; // passiamo al prossimo +Sector
        }
      }

      // Ricostruiamo in formato Flipper
      // Recuperiamo qualche info base da block0
      const block0 = blocks[0] || Array(16).fill("00");
      const uid = block0.slice(0, 4).join(" ");
      const atqa = block0[4] + " " + block0[5];
      const sak = block0[6];

      let result = "";
      result += "Filetype: Flipper NFC device\n";
      result += "Version: 4\n";
      result += "# Device type can be ISO14443-3A, ISO14443-3B, ISO14443-4A, ISO14443-4B, ISO15693-3, FeliCa, NTAG/Ultralight, Mifare Classic, Mifare Plus, Mifare DESFire, SLIX, ST25TB, EMV\n";
      result += "Device type: Mifare Classic\n";
      result += `UID: ${uid}\n`;
      result += `ATQA: ${atqa}\n`;
      result += `SAK: ${sak}\n`;
      result += "Mifare Classic type: 1K\n";
      result += "Data format version: 2\n";
      result += "# Mifare Classic blocks, '??' means unknown data\n";
      for (let blockNum = 0; blockNum < 64; blockNum++) {
        const data = blocks[blockNum] || Array(16).fill("00");
        result += `Block ${blockNum}: ${data.join(" ")}\n`;
      }
      return result;
    }

    // 3) Rigenera il file con eventuali modifiche base
    function generateFileContent() {
      return fileContent;
    }

    // 4) Tasto di conversione.
    document.getElementById("convertBtn").addEventListener("click", function() {
      if (!fileContent) {
        alert(texts[currentLanguage].errorLoad);
        return;
      }
      let newContent = "";
      let newFileExtension = "";
      if (fileExtension === ".nfc") {
        // Converte da Flipper a MCT
        newContent = convertFlipperToMCT(fileContent);
        newFileExtension = ".mct";
      } else if (fileExtension === ".mct") {
        // Converte da MCT a Flipper
        newContent = convertMCTToFlipper(fileContent);
        newFileExtension = ".nfc";
      } else {
        alert("Formato file non supportato");
        return;
      }
      // Scarica il file convertito
      const blob = new Blob([newContent], { type: "text/plain" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "converted_file" + newFileExtension;
      link.click();
      alert(texts[currentLanguage].convertSuccessMsg);
    });
  </script>
</body>
</html>

Made by Lotverp
